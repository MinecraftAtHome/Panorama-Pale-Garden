#include "flowergen.cuh"
#include "cudawrapper.cuh"
#include <cstdio>
#include <chrono>
#include <cmath>


// for initial filter
constexpr int MAX_RESULTS_1 = 1024 * 1024;
__device__ uint64_t results1[MAX_RESULTS_1];
__managed__ int resultID1;

// for secondary filter
constexpr int MAX_RESULTS_2 = 8192;
__device__ uint64_t results2[MAX_RESULTS_2];
__managed__ int resultID2;

// for secondary & final filter
constexpr int MAX_FLOWERS = 32;
//constexpr int MAX_AIRBLOCKS = 48;
__constant__ BlockPos targetFlowers[MAX_FLOWERS];
__constant__ int targetFlowerCount;
//__constant__ BlockPos targetAirblocks[MAX_AIRBLOCKS];
//__constant__ int targetAirblockCount;
__constant__ ChunkPos regionMin, regionMax;

// for final filter
constexpr int MAX_RESULTS_3 = 256; // not gonna be much stuff here
__managed__ uint64_t results3[MAX_RESULTS_3];
__managed__ int resultID3;


__device__ inline void initialFilter(const uint64_t worldseed)
{
    Xoroshiro xrand = { 0ULL, 0ULL };

    // calculate shared constants
    SeedConstants sc = { worldseed, 0ULL, 0ULL };
    xSetSeed(&xrand, worldseed);
    sc.A = (xNextLongJ(&xrand) | 1ULL) << 4;
    sc.B = (xNextLongJ(&xrand) | 1ULL) << 4;

    // first filters - boolean flower generation parameters
    // hardcoded for efficiency, keep in mind while debugging

    // in chunk (191, 20): flower patch (or unlikely single flower at 7,8)
    if (!testFlowerInChunkUnconditional(&xrand, sc, { 191, 20 }, { 7, 8 }))
        return;

    // speed test results for different filter orders
    /*
    1 2 3 -> 13 hours 58 minutes
    1 3 2 -> 14 hours 3 minutes
    2 1 3 -> 14 hours 7 minutes
    2 3 1 -> 14 hours 5 minutes
    3 1 2 -> 14 hours 13 minutes
    3 2 1 -> 14 hours 4 minutes
    */

    // if no flower patch in chunks (190,22), (191,21), (191,22) then 
    // in chunk (190, 21) there must be a flower patch (or unlikely single flower at 9, 9)
    const ChunkPos chunks1[] = QUAD_CHUNK(190, 21, 1, 1);
    const BlockPos2D flower1 = { 9, 9 };
    if (!testFlowerInChunkConditional(&xrand, sc, chunks1, flower1))
        return;

    // if no flower patch in chunks (190,19), (190,18), (191,18) then 
    // in chunk(191, 19) : flower patch (or unlikely single flower at 5, 4)
    const ChunkPos chunks2[] = QUAD_CHUNK(191, 19, -1, -1);
    const BlockPos2D flower2 = { 5, 4 };
    if (!testFlowerInChunkConditional(&xrand, sc, chunks2, flower2))
        return;

    // if no flower patch in chunks(189, 21), (188, 21), (188, 20) then
    // in chunk(189, 20) : flower patch (or unlikely single flower at 0, 11)
    const ChunkPos chunks3[] = QUAD_CHUNK(189, 20, -1, 1);
    const BlockPos2D flower3 = { 0, 11 };
    if (!testFlowerInChunkConditional(&xrand, sc, chunks3, flower3))
        return;

    const int i = atomicAdd(&resultID1, 1);
    if (i >= MAX_RESULTS_1)
    {
        printf("DEVICE ERROR: too many results from initial filter!\n");
        return;
    }

    results1[i] = worldseed;
}

__device__ void secondaryFilter(const uint64_t worldseed)
{
    // create a bitmask for used flowers
    uint32_t usedFlowers = 0;

	// generate flower gen origins for all chunks in the relevant region
    for (int cx = regionMin.x; cx <= regionMax.x; cx++)
    {
        for (int cz = regionMin.z; cz <= regionMax.z; cz++)
        {
            ChunkPos cpos = { cx, cz };
            Xoroshiro xrand = { 0ULL, 0ULL };
            uint64_t popseed = xGetPopulationSeed(worldseed, cx << 4, cz << 4);

            // generate flower patch center and the single flower
            BlockPos2D patchCenter, singleFlower;
            bool hasPatch = getFlowerGenOrigin(popseed, cpos, &patchCenter);
            bool hasSingle = getSingleFlower(popseed, cpos, &singleFlower);

			if (!hasPatch && !hasSingle)
				continue;

            // iterate over all flowers in the target arrangement
			// and mark the ones that could be generated by the features
			const int totalFlowers = targetFlowerCount;
            for (int ix = 0; ix < totalFlowers; ix++)
            {
                const BlockPos2D targetFlower = { targetFlowers[ix].x, targetFlowers[ix].z };

                // single flower check
				if (hasSingle && singleFlower.x == targetFlower.x && singleFlower.z == targetFlower.z)
				{
					usedFlowers |= 1 << ix;
					continue;
				}

                // flower patch check
                if (hasPatch
                    && patchCenter.x - 7 <= targetFlower.x && targetFlower.x <= patchCenter.x + 7
                    && patchCenter.z - 7 <= targetFlower.z && targetFlower.z <= patchCenter.z + 7
                    )
                {
                    usedFlowers |= 1 << ix;
                }

            }
        }
    }

	const uint32_t fullMask = (1 << targetFlowerCount) - 1;
    if (worldseed % 10000 == 0)
        DEBUG_PRINT("usedFlowers: %x, fullMask: %x, targetFcount %d\n", usedFlowers, fullMask, targetFlowerCount);

    if (usedFlowers == fullMask)
    {
		const int i = atomicAdd(&resultID2, 1);
        if (i >= MAX_RESULTS_2)
        {
            printf("DEVICE ERROR: too many results from secondary filter!\n");
            return;
        }

		results2[i] = worldseed;
    }
}

__device__ int matchFlowersForChunk(const uint64_t worldseed, const int cx, const int cz)
{
    uint32_t matchedFlowerMask = 0;
    int matchedFlowerCount = 0;

    // now that we're here, generate the flower patches for the chunk and its neighbors
    for (int dcx = -1; dcx <= 1; dcx++)
    {
        for (int dcz = -1; dcz <= 1; dcz++)
        {
            Xoroshiro xrand = { 0ULL, 0ULL };
            const ChunkPos cpos = { cx + dcx, cz + dcz };
            const uint64_t popseed = xGetPopulationSeed(worldseed, cpos.x << 4, cpos.z << 4);
            xSetSeed(&xrand, popseed + FLOWER_PATCH_SALT);
            if (xNextFloat(&xrand) >= 1.0F / 8.0F)
                continue;

            BlockPos2D patchCenter = { 0, 0 };
            patchCenter.x = xNextIntJPO2(&xrand, 16);
            patchCenter.z = xNextIntJPO2(&xrand, 16);

            // empty chunk for the flowers to go in
            int flowerChunk[7][16] = { 0 }; // x in the integer, y in the first dimension, z in the second dimension
            if (addFlowersToChunk(&xrand, flowerChunk, patchCenter, dcx, dcz) == 0)
                continue;

            // iterate over all relative y values
            for (int y = 0; y < 7; y++)
            {
                // mark all the flowers that could match the pattern at this y level as OK
                // this is a huge simplification, however this way we're avoiding
                // the pseudo-exponential complexity of exact matching

                for (int i = 0; i < targetFlowerCount; i++)
                {
                    const BlockPos flower = targetFlowers[i];
                    if ((flower.x >> 4) != cx || flower.z >> 4 != cz)
                        continue;

                    const BlockPos2D flowerInChunk = { flower.x & 0xf, flower.z & 0xf };

                    if (flowerChunk[y][flowerInChunk.z] & (1 << flowerInChunk.x))
                    {
                        if ((matchedFlowerMask & (1 << i)) != 0)
                            continue;
                        matchedFlowerMask |= 1 << i;
                        matchedFlowerCount++;
                    }
                }
            }
        }
    }

    // don't forget potential single flower
    BlockPos2D singleFlower = { 0, 0 };
    const uint64_t popseed = xGetPopulationSeed(worldseed, cx << 4, cz << 4);
    if (getSingleFlower(popseed, { cx, cz }, &singleFlower))
    {
        for (int i = 0; i < targetFlowerCount; i++)
        {
            const BlockPos flower = targetFlowers[i];
            if (flower.x != singleFlower.x || flower.z != singleFlower.z)
                continue;
            if ((matchedFlowerMask & (1 << i)) != 0)
                continue;

            matchedFlowerMask |= 1 << i;
            matchedFlowerCount++;
        }
    }

    return matchedFlowerCount;
}

__device__ void finalFilter(uint64_t worldseed)
{
    for (int cx = regionMin.x; cx <= regionMax.x; cx++)
    {
        for (int cz = regionMin.z; cz <= regionMax.z; cz++)
        {
            // count target flowers that lie within the chunk

            int targetsInChunk = 0;
            for (int i = 0; i < targetFlowerCount; i++)
            {
                const BlockPos flower = targetFlowers[i];
				if ((flower.x >> 4) == cx && (flower.z >> 4) == cz)
					targetsInChunk++;
            }
            if (targetsInChunk == 0) 
                continue; // not wasting time

            int matchedFlowers = matchFlowersForChunk(worldseed, cx, cz);

            if (matchedFlowers < targetsInChunk)
				return; // not enough flowers in the chunk	
        }
    }

	const int i = atomicAdd(&resultID3, 1);
	if (i >= MAX_RESULTS_3)
	{
		printf("DEVICE ERROR: too many results from final filter!\n");
		return;
	}

	results3[i] = worldseed;
}

// --------------------------------------------------------------------------------------------

static int setupConstantMemory()
{
    FILE* fptr = fopen("data/flowers.txt", "r");
    if (fptr == NULL)
        HOST_ERROR("couldn't open input file");

    BlockPos flowers[MAX_FLOWERS];
    //BlockPos airblocks[MAX_AIRBLOCKS];
    int flowerCount = 0, airblockCount = 0;

    BlockPos2D posMin = { INT_MAX, INT_MAX };
    BlockPos2D posMax = { INT_MIN, INT_MIN };

    while (flowerCount < MAX_FLOWERS && fscanf(fptr, "%d%d%d", &(flowers[flowerCount].x), &(flowers[flowerCount].y), &(flowers[flowerCount].z)) == 3)
    {
        if (flowers[flowerCount].x < posMin.x) posMin.x = flowers[flowerCount].x;
        if (flowers[flowerCount].z < posMin.z) posMin.z = flowers[flowerCount].z;
        if (flowers[flowerCount].x > posMax.x) posMax.x = flowers[flowerCount].x;
        if (flowers[flowerCount].z > posMax.z) posMax.z = flowers[flowerCount].z;
        flowerCount++;
    }

    fclose(fptr);

    //fptr = fopen("data/no_air.txt", "r");
    //if (fptr == NULL)
    //    HOST_ERROR("couldn't open input file");
    //
    //while (airblockCount < MAX_AIRBLOCKS && fscanf(fptr, "%d%d%d", &(airblocks[airblockCount].x), &(airblocks[airblockCount].y), &(airblocks[airblockCount].z)) == 3)
    //    airblockCount++;
    //
    //fclose(fptr);

    DEBUG_PRINT("flowerCount: %d, airblockCount: %d\n", flowerCount, airblockCount);

    CHECKED_OPERATION(cudaMemcpyToSymbol(targetFlowers, flowers, sizeof(BlockPos) * flowerCount));
    CHECKED_OPERATION(cudaMemcpyToSymbol(targetFlowerCount, &flowerCount, sizeof(int)));
    //CHECKED_OPERATION(cudaMemcpyToSymbol(targetAirblocks, airblocks, sizeof(BlockPos) * airblockCount));
    //CHECKED_OPERATION(cudaMemcpyToSymbol(targetAirblockCount, &airblockCount, sizeof(int)));

    // calculate the bounds for the region of relevant chunks
    ChunkPos regionMin_H = { (posMin.x - 7) >> 4, (posMin.z - 7) >> 4 };
    ChunkPos regionMax_H = { (posMax.x + 7) >> 4, (posMax.z + 7) >> 4 };

    CHECKED_OPERATION(cudaMemcpyToSymbol(regionMin, &regionMin_H, sizeof(ChunkPos)));
    CHECKED_OPERATION(cudaMemcpyToSymbol(regionMax, &regionMax_H, sizeof(ChunkPos)));

    return 0;
}

__global__ void crackSeedPart2()
{
    int tid = threadIdx.x + blockDim.x * blockIdx.x;
    if (tid >= resultID1) return;

    const uint64_t worldseed = results1[tid];

    secondaryFilter(worldseed);
}

__global__ void crackSeedPart3()
{
    int tid = threadIdx.x + blockDim.x * blockIdx.x;
    if (tid >= resultID2) return;

    const uint64_t worldseed = results2[tid];

    finalFilter(worldseed);
}

// ----------------------------------------------------------------

constexpr uint64_t TEXT_SEEDS_TOTAL = 1ULL << 32;

__global__ void crackTextSeedPart1()
{
    uint64_t tid = threadIdx.x + (uint64_t)blockDim.x * blockIdx.x;
    if (tid >= TEXT_SEEDS_TOTAL) return;

    // extend the sign bit if necessary
    uint64_t worldseed = tid;
    if ((worldseed & 0x80000000ULL) != 0ULL)
        worldseed |= 0xffffffff00000000;

    initialFilter(worldseed);
}

static int runCrackerTextSeeds()
{
    CHECKED_OPERATION(cudaSetDevice(0));

    if (setupConstantMemory() != 0)
        return 1;

    auto start = std::chrono::high_resolution_clock::now();

    resultID1 = 0;
    resultID2 = 0;
    resultID3 = 0;

    const int THREADS_PER_BLOCK = 512;

    const int NUM_BLOCKS_1 = (TEXT_SEEDS_TOTAL + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackTextSeedPart1 <<< NUM_BLOCKS_1, THREADS_PER_BLOCK >> > ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());
    printf("After filter 1: %d\n", resultID1);

    const int NUM_BLOCKS_2 = (resultID1 + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackSeedPart2 <<< NUM_BLOCKS_2, THREADS_PER_BLOCK >> > ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());
    printf("After filter 2: %d\n", resultID2);

    const int NUM_BLOCKS_3 = (resultID2 + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackSeedPart3 <<< NUM_BLOCKS_3, THREADS_PER_BLOCK >>> ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());
    printf("After filter 3: %d\n\n", resultID3);

    for (int i = 0; i < resultID3; i++)
    {
        printSignedSeed(results3[i]);
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = end - start;
    double ms = (double)elapsed.count() / 1000000.0;
    printf("\nKernel took %lf ms\n", ms);

    CHECKED_OPERATION(cudaDeviceReset());

    return 0;
}

// ----------------------------------------------------------------

constexpr uint64_t RANDOM_SEEDS_TOTAL = 1ULL << 48;
constexpr uint64_t THREADS_LAUNCHED_PER_RUN = 1ULL << 31;
//constexpr uint8_t BITS_PER_THREAD = 0;
//constexpr int RANDOM_SEEDS_PER_THREAD = 1 << BITS_PER_THREAD;
constexpr uint64_t RANDOM_SEEDS_PER_RUN = THREADS_LAUNCHED_PER_RUN;
constexpr int NUM_RUNS_RANDOM_SEEDS = (RANDOM_SEEDS_TOTAL + RANDOM_SEEDS_PER_RUN - 1) / RANDOM_SEEDS_PER_RUN;
constexpr int RUNS_PER_PRINT = 100;

__global__ void crackRandomSeedPart1(const uint64_t offset)
{
    // tid is the first state of java random used in the nextLong()
    const uint64_t tid = threadIdx.x + (uint64_t)blockDim.x * blockIdx.x + offset;
    if (tid >= RANDOM_SEEDS_TOTAL) return;
	
    //#pragma unroll
    //for (uint32_t low = 0; low < RANDOM_SEEDS_PER_THREAD; low++)
    //{
		//const uint64_t firstState = tid | low;
        const uint64_t secondState = (tid * JRAND_MULTIPLIER + JRAND_ADDEND) & MASK48;
        const int toAdd = (int)(secondState >> 16);
        const uint64_t worldseed = ((tid >> 16) << 32) + toAdd;

        initialFilter(worldseed);
    //}
}

static int runCrackerRandomSeeds(int runStart, int runEnd)
{
    if (runStart < 0) runStart = 0;
    if (runEnd > NUM_RUNS_RANDOM_SEEDS) runEnd = NUM_RUNS_RANDOM_SEEDS;

    CHECKED_OPERATION(cudaSetDevice(0));

    if (setupConstantMemory() != 0)
        return 1;

#ifdef STATS
    auto startGlobal = std::chrono::steady_clock::now();
    auto start = std::chrono::steady_clock::now();
    //double ms1 = 0.0, ms2 = 0.0, ms3 = 0.0;
#endif

    for (int run = runStart; run < runEnd; run++)
    {
#ifdef STATS
        if (run % RUNS_PER_PRINT == 0)
        {
            start = std::chrono::steady_clock::now();
            printf(" --- Run %d / %d\n", run + 1, NUM_RUNS_RANDOM_SEEDS);
        }
#endif
			
        resultID1 = 0;
        resultID2 = 0;
        resultID3 = 0;

        const int THREADS_PER_BLOCK = 512;
        const int NUM_BLOCKS_1 = (THREADS_LAUNCHED_PER_RUN + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;

        //auto s1 = std::chrono::steady_clock::now();
        crackRandomSeedPart1 << < NUM_BLOCKS_1, THREADS_PER_BLOCK >> > (run * THREADS_LAUNCHED_PER_RUN);
        CHECKED_OPERATION(cudaGetLastError());
        CHECKED_OPERATION(cudaDeviceSynchronize());
        //auto e1 = std::chrono::steady_clock::now();
        //ms1 += (e1 - s1).count() / 1000000.0;

        const int NUM_BLOCKS_2 = (resultID1 + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
        if (NUM_BLOCKS_2 == 0)
            continue;

        //auto s2 = std::chrono::steady_clock::now(); 
        crackSeedPart2 << < NUM_BLOCKS_2, THREADS_PER_BLOCK >> > ();
        CHECKED_OPERATION(cudaGetLastError());
        CHECKED_OPERATION(cudaDeviceSynchronize());
        //auto e2 = std::chrono::steady_clock::now();
        //ms2 += (e2 - s2).count() / 1000000.0;

        const int NUM_BLOCKS_3 = (resultID2 + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
        if (NUM_BLOCKS_3 == 0)
            continue;

        //auto s3 = std::chrono::steady_clock::now();
        crackSeedPart3 << < NUM_BLOCKS_3, THREADS_PER_BLOCK >> > ();
        CHECKED_OPERATION(cudaGetLastError());
        CHECKED_OPERATION(cudaDeviceSynchronize());
        //auto e3 = std::chrono::steady_clock::now();
        //ms3 += (e3 - s3).count() / 1000000.0;

        for (int i = 0; i < resultID3; i++)
        {
            printSignedSeed(results3[i]);
        }

#ifdef STATS
        if (run % RUNS_PER_PRINT == RUNS_PER_PRINT - 1)
        {
            auto end = std::chrono::steady_clock::now();
            auto elapsed = end - start;
			double ms = (double)elapsed.count() / 1000000.0 / (double)RUNS_PER_PRINT;

            // calc eta based on this run
            double eta_s = ms * (runEnd - run) / 1000.0;
            int sec = (int)floor(eta_s) % 60;
            double eta_min = eta_s / 60.0;
            int min = (int)floor(eta_min) % 60;
            double eta_h = eta_min / 60.0;
            int hrs = (int)floor(eta_h);
            fprintf(stderr, "ETA: %d HRS %d MIN %d SEC\n", hrs, min, sec);
        }
#endif
    }

    CHECKED_OPERATION(cudaDeviceReset());

#ifdef STATS
    auto endGlobal = std::chrono::steady_clock::now();
    auto elapsedGlobal = endGlobal - startGlobal;
    double seconds = (double)elapsedGlobal.count() / 1000000.0 / 1000.0;
    printf("Runs took %lf seconds in total:\n", seconds);

    //printf("Filter 1: %lf sec\n", ms1 / 1000.0);
    //printf("Filter 2: %lf sec\n", ms2 / 1000.0);
    //printf("Filter 3: %lf sec\n", ms3 / 1000.0);

    double minutesFull = seconds / 60.0 * NUM_RUNS_RANDOM_SEEDS / (runEnd - runStart);
    int min = (int)floor(minutesFull) % 60;
    int hrs = (int)floor(minutesFull / 60.0);
    printf("\nEstimated runtime for full seedspace: %d hours %d minutes\n", hrs, min);
#endif

    return 0;
}

// ------------------------------------------------------

int main(int argc, char** argv)
{
    if (argc <= 2)
        HOST_ERROR("usage: ./executable rangeStartInclusive rangeEndExclusive [otherArgs]");

    int rangeStart = atoi(argv[1]);
    int rangeEnd = atoi(argv[2]);

	return runCrackerRandomSeeds(rangeStart, rangeEnd);
}
