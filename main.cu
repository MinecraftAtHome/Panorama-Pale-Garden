#include "flowergen.cuh"
#include "cudawrapper.cuh"
#include <cstdio>
#include <chrono>

// for initial filter
constexpr int MAX_RESULTS_1 = 1024 * 1024;
__device__ uint64_t results1[MAX_RESULTS_1];
__managed__ int resultID1;

// for secondary filter
constexpr int MAX_RESULTS_2 = 65536;
__device__ uint64_t results2[MAX_RESULTS_2];
__managed__ int resultID2;

// for secondary & final filter
constexpr int MAX_FLOWERS = 32;
constexpr int MAX_AIRBLOCKS = 48;
__constant__ BlockPos targetFlowers[MAX_FLOWERS];
__constant__ int targetFlowerCount;
__constant__ BlockPos targetAirblocks[MAX_AIRBLOCKS];
__constant__ int targetAirblockCount;
__constant__ ChunkPos regionMin, regionMax;

// for final filter
constexpr int MAX_RESULTS_3 = 1024; // not gonna be much stuff here
__managed__ uint64_t results3[MAX_RESULTS_3];
__managed__ int resultID3;




__device__ void initialFilter(const uint64_t worldseed)
{
    Xoroshiro xrand = { 0ULL, 0ULL };

    // first filters - boolean flower generation parameters
    // hardcoded for efficiency, keep in mind while debugging

    // in chunk (191, 20): flower patch (or unlikely single flower at 7,8)
    if (!testFlowerInChunkUnconditional(&xrand, worldseed, { 191, 20 }, { 7, 8 }))
        return;

    // conditional filters

    // if no flower patch in chunks (190,22), (191,21), (191,22) then 
    // in chunk (190, 21) there must be a flower patch (or unlikely single flower at 9, 9)
    const ChunkPos chunks1[] = { {190, 22},   {191, 21},   {191, 22},   {190, 21} };
    const BlockPos2D flower1 = { 9, 9 };
    if (!testFlowerInChunkConditional(&xrand, worldseed, chunks1, flower1))
        return;
        
    // if no flower patch in chunks (190,19), (190,18), (191,18) then 
    // in chunk(191, 19) : flower patch (or unlikely single flower at 5, 4)
    const ChunkPos chunks2[] = { {190, 19},   {190, 18},   {191, 18},   {191, 19} };
    const BlockPos2D flower2 = { 5, 4 };
    if (!testFlowerInChunkConditional(&xrand, worldseed, chunks2, flower2))
        return;

    // if no flower patch in chunks(188, 20), (188, 19), (189, 19) then
    // in chunk(189, 20) : flower patch (or unlikely single flower at 0, 11)
    const ChunkPos chunks3[] = { {188, 20},   {188, 19},   {189, 19},   {189, 20} };
    const BlockPos2D flower3 = { 0, 11 };
    if (!testFlowerInChunkConditional(&xrand, worldseed, chunks3, flower3))
        return;

    const int i = atomicAdd(&resultID1, 1);
    if (i >= MAX_RESULTS_1)
        printf("DEVICE ERROR: too many results from initial filter!\n");

    results1[i] = worldseed;
}

__device__ void secondaryFilter(const uint64_t worldseed)
{
    // create a bitmask for used flowers
    uint32_t usedFlowers = 0;

	// generate flower gen origins for all chunks in the relevant region
    for (int cx = regionMin.x; cx <= regionMax.x; cx++)
    {
        for (int cz = regionMin.z; cz <= regionMax.z; cz++)
        {
            ChunkPos cpos = { cx, cz };
            Xoroshiro xrand = { 0ULL, 0ULL };
            uint64_t popseed = xGetPopulationSeed(worldseed, cx << 4, cz << 4);

            // generate flower patch center and the single flower
            BlockPos2D patchCenter, singleFlower;
            bool hasPatch = getFlowerGenOrigin(popseed, cpos, &patchCenter);
            bool hasSingle = getSingleFlower(popseed, cpos, &singleFlower);

			if (!hasPatch && !hasSingle)
				continue;

            // iterate over all flowers in the target arrangement
			// and mark the ones that could be generated by the features
			const int totalFlowers = targetFlowerCount;
            for (int ix = 0; ix < totalFlowers; ix++)
            {
                const BlockPos2D targetFlower = { targetFlowers[ix].x, targetFlowers[ix].z };

                // single flower check
				if (hasSingle && singleFlower.x == targetFlower.x && singleFlower.z == targetFlower.z)
				{
					usedFlowers |= 1 << ix;
					continue;
				}

                // flower patch check
                if (hasPatch
                    && patchCenter.x - 7 <= targetFlower.x && targetFlower.x <= patchCenter.x + 7
                    && patchCenter.z - 7 <= targetFlower.z && targetFlower.z <= patchCenter.z + 7
                    )
                {
                    usedFlowers |= 1 << ix;
                }

            }
        }
    }

	const uint32_t fullMask = (1 << targetFlowerCount) - 1;
    if (worldseed % 10000 == 0)
        DEBUG_PRINT("usedFlowers: %x, fullMask: %x, targetFcount %d\n", usedFlowers, fullMask, targetFlowerCount);

    if (usedFlowers == fullMask)
    {
		const int i = atomicAdd(&resultID2, 1);
		if (i >= MAX_RESULTS_2)
			printf("DEVICE ERROR: too many results from secondary filter!\n");

		results2[i] = worldseed;
    }
}

__device__ int matchFlowersForChunk(const uint64_t worldseed, const int cx, const int cz)
{
    uint32_t matchedFlowerMask = 0;
    int matchedFlowerCount = 0;

    // now that we're here, generate the flower patches for the chunk and its neighbors
    for (int dcx = -1; dcx <= 1; dcx++)
    {
        for (int dcz = -1; dcz <= 1; dcz++)
        {
            Xoroshiro xrand = { 0ULL, 0ULL };
            const ChunkPos cpos = { cx + dcx, cz + dcz };
            const uint64_t popseed = xGetPopulationSeed(worldseed, cpos.x << 4, cpos.z << 4);
            xSetSeed(&xrand, popseed + FLOWER_PATCH_SALT);
            if (xNextFloat(&xrand) >= 1.0F / 8.0F)
                continue;

            BlockPos2D patchCenter = { 0, 0 };
            patchCenter.x = xNextIntJPO2(&xrand, 16);
            patchCenter.z = xNextIntJPO2(&xrand, 16);

            // empty chunk for the flowers to go in
            int flowerChunk[7][16] = { 0 }; // x in the integer, y in the first dimension, z in the second dimension
            if (addFlowersToChunk(&xrand, flowerChunk, patchCenter) == 0)
                continue;

            // try to fit the y-value so that air blocks match
            int forbiddenY = 0;

            // do air blocks first, eliminating some y values
            for (int i = 0; i < targetAirblockCount; i++)
            {
                const BlockPos airblock = targetAirblocks[i];
                if ((airblock.x >> 4) != cx || (airblock.z >> 4) != cz)
                    continue;

                const BlockPos2D airblockInChunk = { airblock.x & 0xf, airblock.z & 0xf };
                for (int y = 0; y < 7; y++)
                {
                    if (flowerChunk[y][airblockInChunk.z] & (1 << airblockInChunk.x))
                        forbiddenY |= 1 << y;
                }
            }

            // if there are no possible y values, this chunk cannot affect the original chunk's generation
            if (forbiddenY == (1 << 7) - 1)
                continue;

			// iterate over non-forbidden y values
			for (int y = 0; y < 7; y++)
			{
				if (forbiddenY & (1 << y))
					continue;

				// mark all the flowers that could match the pattern at this y level as OK
                // this is a huge simplification, however this way we're avoiding
				// the pseudo-exponential complexity of exact matching

				for (int i = 0; i < targetFlowerCount; i++)
				{
                    const BlockPos flower = targetFlowers[i];
					if ((flower.x >> 4) != cx || flower.z >> 4 != cz)
					    continue;

					const BlockPos2D flowerInChunk = { flower.x & 0xf, flower.z & 0xf };

					if (flowerChunk[y][flowerInChunk.z] & (1 << flowerInChunk.x))
					{
						if ((matchedFlowerMask & (1 << i)) != 0)
						    continue;
						matchedFlowerMask |= 1 << i;
						matchedFlowerCount++;
					}
				}
			}
        }
    }

	return matchedFlowerCount;
}

__device__ void finalFilter(uint64_t worldseed)
{
    for (int cx = regionMin.x; cx <= regionMax.x; cx++)
    {
        for (int cz = regionMin.z; cz <= regionMax.z; cz++)
        {
            // count target flowers that lie within the chunk

            int targetsInChunk = 0;
            for (int i = 0; i < targetFlowerCount; i++)
            {
                const BlockPos flower = targetFlowers[i];
				if ((flower.x >> 4) == cx && (flower.z >> 4) == cz)
					targetsInChunk++;
            }
            if (targetsInChunk == 0) 
                continue; // not wasting time

            int matchedFlowers = matchFlowersForChunk(worldseed, cx, cz);

			if (matchedFlowers != targetsInChunk)
				return; // not enough flowers in the chunk	
        }
    }

	const int i = atomicAdd(&resultID3, 1);
	if (i >= MAX_RESULTS_3)
		printf("DEVICE ERROR: too many results from final filter!\n");
	results3[i] = worldseed;
}

// --------------------------------------------------------------------------------------------

constexpr uint64_t TEXT_SEEDS_TOTAL = 1ULL << 32;

__global__ void crackTextSeedPart1()
{
    uint64_t tid = threadIdx.x + (uint64_t)blockDim.x * blockIdx.x;
    if (tid >= TEXT_SEEDS_TOTAL) return;

    // extend the sign bit if necessary
    uint64_t worldseed = tid;
    if ((worldseed & 0x80000000ULL) != 0ULL)
        worldseed |= 0xffffffff00000000;

    initialFilter(worldseed);
}

__global__ void crackTextSeedPart2()
{
    int tid = threadIdx.x + blockDim.x * blockIdx.x;
    if (tid >= resultID1) return;

    const uint64_t worldseed = results1[tid];

    secondaryFilter(worldseed);
}

__global__ void crackTextSeedPart3()
{
    int tid = threadIdx.x + blockDim.x * blockIdx.x;
    if (tid >= resultID2) return;

    const uint64_t worldseed = results2[tid];

    finalFilter(worldseed);
}


int setupConstantMemory()
{
    FILE* fptr = fopen("data/flowers.txt", "r");
    if (fptr == NULL)
        HOST_ERROR("couldn't open input file");

    BlockPos flowers[MAX_FLOWERS];
    BlockPos airblocks[MAX_AIRBLOCKS];
    int flowerCount = 0, airblockCount = 0;

    BlockPos2D posMin = { INT_MAX, INT_MAX };
    BlockPos2D posMax = { INT_MIN, INT_MIN };

    while (flowerCount < MAX_FLOWERS && fscanf(fptr, "%d%d%d", &(flowers[flowerCount].x), &(flowers[flowerCount].y), &(flowers[flowerCount].z)) == 3)
    {
		if (flowers[flowerCount].x < posMin.x) posMin.x = flowers[flowerCount].x;
		if (flowers[flowerCount].z < posMin.z) posMin.z = flowers[flowerCount].z;
		if (flowers[flowerCount].x > posMax.x) posMax.x = flowers[flowerCount].x;
		if (flowers[flowerCount].z > posMax.z) posMax.z = flowers[flowerCount].z;
        flowerCount++;
    }

    fclose(fptr);

    fptr = fopen("data/airblocks.txt", "r");
    if (fptr == NULL)
        HOST_ERROR("couldn't open input file");

    while (airblockCount < MAX_AIRBLOCKS && fscanf(fptr, "%d%d%d", &(airblocks[airblockCount].x), &(airblocks[airblockCount].y), &(airblocks[airblockCount].z)) == 3)
		airblockCount++;

    fclose(fptr);

	DEBUG_PRINT("flowerCount: %d, airblockCount: %d\n", flowerCount, airblockCount);

	CHECKED_OPERATION( cudaMemcpyToSymbol(targetFlowers, flowers, sizeof(BlockPos) * flowerCount) );
    CHECKED_OPERATION( cudaMemcpyToSymbol(targetFlowerCount, &flowerCount, sizeof(int)) );
    CHECKED_OPERATION(cudaMemcpyToSymbol(targetAirblocks, airblocks, sizeof(BlockPos) * airblockCount));
    CHECKED_OPERATION(cudaMemcpyToSymbol(targetAirblockCount, &airblockCount, sizeof(int)));

	// calculate the bounds for the region of relevant chunks
	ChunkPos regionMin_H = { (posMin.x - 7) >> 4, (posMin.z - 7) >> 4 };
	ChunkPos regionMax_H = { (posMax.x + 7) >> 4, (posMax.z + 7) >> 4 };

	CHECKED_OPERATION( cudaMemcpyToSymbol(regionMin, &regionMin_H, sizeof(ChunkPos)) );
	CHECKED_OPERATION( cudaMemcpyToSymbol(regionMax, &regionMax_H, sizeof(ChunkPos)) );

	return 0;
}

int runCracker()
{
    CHECKED_OPERATION(cudaSetDevice(0));

    auto start = std::chrono::high_resolution_clock::now();

    if (setupConstantMemory() != 0)
        return 1;

    resultID1 = 0;
    resultID2 = 0;
    resultID3 = 0;

    const int THREADS_PER_BLOCK = 512;

    const int NUM_BLOCKS_1 = (TEXT_SEEDS_TOTAL + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackTextSeedPart1 <<< NUM_BLOCKS_1, THREADS_PER_BLOCK >> > ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());
    printf("After filter 1: %d\n", resultID1);

    const int NUM_BLOCKS_2 = (resultID1 + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackTextSeedPart2 <<< NUM_BLOCKS_2, THREADS_PER_BLOCK >> > ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());
    printf("After filter 2: %d\n", resultID2);

    const int NUM_BLOCKS_3 = (resultID2 + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackTextSeedPart3 <<< NUM_BLOCKS_3, THREADS_PER_BLOCK >>> ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());
    printf("After filter 3: %d\n\n", resultID3);

    for (int i = 0; i < resultID3; i++)
    {
        printSignedSeed(results3[i]);
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = end - start;
    double ms = (double)elapsed.count() / 1000000.0;
    printf("\nKernel took %lf ms\n", ms);

    CHECKED_OPERATION(cudaDeviceReset());

    return 0;
}



int main()
{
	return runCracker();
}
