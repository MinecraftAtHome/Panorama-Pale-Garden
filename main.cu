#include "flowergen.cuh"
#include "cudawrapper.cuh"
#include <cstdio>
#include <chrono>

constexpr uint32_t MIN_X = 0;
constexpr uint32_t MAX_X = 31;
constexpr uint32_t MIN_Z = 0;
constexpr uint32_t MAX_Z = 31;
constexpr uint32_t MIN_Y = 111;
constexpr uint32_t MAX_Y = 112;

// for initial filter
constexpr int MAX_RESULTS_1 = 1024 * 1024;
__device__ uint64_t results1[MAX_RESULTS_1];
__managed__ int resultID1;

// for secondary filter
constexpr int MAX_FLOWERS = 32;
__constant__ BlockPos targetFlowers[MAX_FLOWERS];
__constant__ int targetFlowerCount;
__constant__ ChunkPos regionMin, regionMax;

constexpr int MAX_RESULTS_2 = 1024 * 1024; // don't really know how many results to expect
__device__ uint64_t results2[MAX_RESULTS_2];
__managed__ int resultID2;

// for final filter
constexpr uint32_t SIZE_I = (MAX_X - MIN_X + 32) / 32;  // x
constexpr uint32_t SIZE_J = MAX_Y - MIN_Y + 1;          // y
constexpr uint32_t SIZE_K = MAX_Z - MIN_Z + 1;          // z
__constant__ uint32_t targetPatternFlowers[SIZE_I][SIZE_J][SIZE_K];
__constant__ uint32_t targetPatternAirblocks[SIZE_I][SIZE_J][SIZE_K];



__device__ void initialFilter(uint64_t worldseed)
{
    Xoroshiro xrand = { 0ULL, 0ULL };

    // first filters - boolean flower generation parameters
    // hardcoded for efficiency, keep in mind while debugging

    // in chunk (191, 20): flower patch (or unlikely single flower at 7,8)
    if (!testFlowerInChunkUnconditional(&xrand, worldseed, { 191, 20 }, { 7, 8 }))
        return;

    // conditional filters

    // if no flower patch in chunks (190,22), (191,21), (191,22) then 
    // in chunk (190, 21) there must be a flower patch (or unlikely single flower at 9, 9)
    const ChunkPos chunks1[] = { {190, 22},   {191, 21},   {191, 22},   {190, 21} };
    const BlockPos2D flower1 = { 9, 9 };
    if (!testFlowerInChunkConditional(&xrand, worldseed, chunks1, flower1))
        return;
        
    // if no flower patch in chunks (190,19), (190,18), (191,18) then 
    // in chunk(191, 19) : flower patch (or unlikely single flower at 5, 4)
    const ChunkPos chunks2[] = { {190, 19},   {190, 18},   {191, 18},   {191, 19} };
    const BlockPos2D flower2 = { 5, 4 };
    if (!testFlowerInChunkConditional(&xrand, worldseed, chunks2, flower2))
        return;

    // if no flower patch in chunks(188, 20), (188, 19), (189, 19) then
    // in chunk(189, 20) : flower patch (or unlikely single flower at 0, 11)
    const ChunkPos chunks3[] = { {188, 20},   {188, 19},   {189, 19},   {189, 20} };
    const BlockPos2D flower3 = { 0, 11 };
    if (!testFlowerInChunkConditional(&xrand, worldseed, chunks3, flower3))
        return;

    const int i = atomicAdd(&resultID1, 1);
    if (i >= MAX_RESULTS_1)
        printf("DEVICE ERROR: too many results from initial filter!\n");

    results1[i] = worldseed;
}

__device__ void secondaryFilter(uint64_t worldseed)
{
    // create a bitmask for used flowers
    uint32_t usedFlowers = 0;

	// generate flower gen origins for all chunks in the relevant region
    for (int cx = regionMin.x; cx <= regionMax.x; cx++)
    {
        for (int cz = regionMin.z; cz <= regionMax.z; cz++)
        {
            ChunkPos cpos = { cx, cz };
            Xoroshiro xrand = { 0ULL, 0ULL };
            uint64_t popseed = xGetPopulationSeed(worldseed, cx << 4, cz << 4);

            // generate flower patch center and the single flower
            BlockPos2D patchCenter, singleFlower;
            bool hasPatch = getFlowerGenOrigin(popseed, cpos, &patchCenter);
            bool hasSingle = getSingleFlower(popseed, cpos, &singleFlower);

			if (!hasPatch && !hasSingle)
				continue;

            // iterate over all flowers in the target arrangement
			// and mark the ones that could be generated by the features

            // TODO
        }
    }
}

__device__ void finalFilter(uint64_t worldseed)
{
    // the target flower arrangement, as well as the target known air block arrangement,
    // are stored in gpu constant memory as 3D integer arrays. Each bit maps to a certain
    // block coordinate, as shown below:

    // (block Y is the third dimension)
    // -------------------------------------> block X
    // | [0100...10][0100...10][0100...10]
    // | [0100...10][0100...10][0100...10]
    // | ...
    // | [0100...10][0100...10][0100...10]
    // | [0100...10][0100...10][0100...10]
    // v
    // block Z

    // the coordinates are not mapped directly, to access the block at (X, Y, Z), we need
    // to subtract (Xmin, Ymin, Zmin) first and only then access the correct integer's bit.

    // The second filter's job is to generate the flower positions for all chunks that could generate
    // the visible flowers, match the y-heights of the generated flowers to minimize the error rate,
    // and ultimately only leave in seeds for which the minimum error is below an arbitrary threashold.

    // TODO how the fuck do i even start
}

// --------------------------------------------------------------------------------------------

constexpr uint64_t TEXT_SEEDS_TOTAL = 1ULL << 32;

__global__ void crackTextSeedPart1()
{
    uint64_t tid = threadIdx.x + (uint64_t)blockDim.x * blockIdx.x;
    if (tid >= TEXT_SEEDS_TOTAL) return;

    // extend the sign bit if necessary
    uint64_t worldseed = tid;
    if ((worldseed & 0x80000000ULL) != 0ULL)
        worldseed |= 0xffffffff00000000;

    initialFilter(worldseed);
}

__global__ void crackTextSeedPart2()
{
    int tid = threadIdx.x + blockDim.x * blockIdx.x;
    if (tid >= resultID1) return;

    uint64_t worldseed = results1[tid];

    secondaryFilter(worldseed);
}



int setupConstantMemory()
{
    FILE* fptr = fopen("data/flowers.txt", "r");
    if (fptr == NULL)
        HOST_ERROR("couldn't open input file");

    BlockPos flowers[MAX_FLOWERS];
    int flowerCount = 0;

    BlockPos2D posMin = { INT_MAX, INT_MAX };
    BlockPos2D posMax = { INT_MIN, INT_MIN };

    while (flowerCount < MAX_FLOWERS && fscanf(fptr, "%d%d%d", &(flowers[flowerCount].x), &(flowers[flowerCount].y), &(flowers[flowerCount].z)) == 3)
    {
		if (flowers[flowerCount].x < posMin.x) posMin.x = flowers[flowerCount].x;
		if (flowers[flowerCount].z < posMin.z) posMin.z = flowers[flowerCount].z;
		if (flowers[flowerCount].x > posMax.x) posMax.x = flowers[flowerCount].x;
		if (flowers[flowerCount].z > posMax.z) posMax.z = flowers[flowerCount].z;
        flowerCount++;
    }

    fclose(fptr);

	CHECKED_OPERATION( cudaMemcpyToSymbol(targetFlowers, flowers, sizeof(BlockPos) * flowerCount) );
    CHECKED_OPERATION( cudaMemcpyToSymbol(targetFlowerCount, &flowerCount, sizeof(int)) );

	// calculate the bounds for the region of relevant chunks
	ChunkPos regionMin_H = { (posMin.x - 7) >> 4, (posMin.z - 7) >> 4 };
	ChunkPos regionMax_H = { (posMax.x + 7) >> 4, (posMax.z + 7) >> 4 };

	CHECKED_OPERATION( cudaMemcpyToSymbol(regionMin, &regionMin_H, sizeof(ChunkPos)) );
	CHECKED_OPERATION( cudaMemcpyToSymbol(regionMax, &regionMax_H, sizeof(ChunkPos)) );

	return 0;
}

int main()
{
    CHECKED_OPERATION( cudaSetDevice(0) );

    auto start = std::chrono::high_resolution_clock::now();

    if (setupConstantMemory() != 0)
        return 1;

    resultID1 = 0;
    resultID2 = 0;

    const int THREADS_PER_BLOCK = 512;

    const int NUM_BLOCKS_1 = (TEXT_SEEDS_TOTAL + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackTextSeedPart1 <<< NUM_BLOCKS_1, THREADS_PER_BLOCK >>> ();
    CHECKED_OPERATION( cudaGetLastError() );
    CHECKED_OPERATION( cudaDeviceSynchronize() );

	const int NUM_BLOCKS_2 = (resultID1 + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackTextSeedPart2 <<< NUM_BLOCKS_2, THREADS_PER_BLOCK >>> ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());

    printf("After filter 1: %d\n", resultID1);
    printf("After filter 2: %d\n", resultID2);

    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = end - start;
    double ms = (double)elapsed.count() / 1000000.0;
    printf("Kernel took %lf ms\n", ms);

    CHECKED_OPERATION( cudaDeviceReset() );

    return 0;
}
