#include "flowergen.cuh"
#include "cudawrapper.cuh"
#include <cstdio>
#include <chrono>


constexpr uint64_t CORRECT_SEED = 6969ULL;


// for secondary filter
constexpr int MAX_FLOWERS = 32;
__constant__ BlockPos targetFlowers[MAX_FLOWERS];
__constant__ int targetFlowerCount;
__constant__ ChunkPos regionMin, regionMax;

constexpr int MAX_RESULTS_2 = 1024 * 1024; // don't really know how many results to expect
__device__ uint64_t results2[MAX_RESULTS_2];
__managed__ int resultID2;


__device__ void secondaryFilter(uint64_t worldseed)
{
    // create a bitmask for used flowers
    uint32_t usedFlowers = 0;

    if (worldseed == CORRECT_SEED)
        printf("Testing correct seed.\n");

    // generate flower gen origins for all chunks in the relevant region
    for (int cx = regionMin.x; cx <= regionMax.x; cx++)
    {
        for (int cz = regionMin.z; cz <= regionMax.z; cz++)
        {
            ChunkPos cpos = { cx, cz };
            Xoroshiro xrand = { 0ULL, 0ULL };
            uint64_t popseed = xGetPopulationSeed(worldseed, cx << 4, cz << 4);

            // generate flower patch center and the single flower
            BlockPos2D patchCenter, singleFlower;
            bool hasPatch = getFlowerGenOrigin(popseed, cpos, &patchCenter);
            bool hasSingle = getSingleFlower(popseed, cpos, &singleFlower);

            if (!hasPatch && !hasSingle)
                continue;

            // iterate over all flowers in the target arrangement
            // and mark the ones that could be generated by the features
            const int totalFlowers = targetFlowerCount;
            for (int ix = 0; ix < totalFlowers; ix++)
            {
                const BlockPos2D targetFlower = { targetFlowers[ix].x, targetFlowers[ix].z };

                // single flower check
                if (hasSingle && singleFlower.x == targetFlower.x && singleFlower.z == targetFlower.z)
                {
                    usedFlowers |= 1 << ix;
                    continue;
                }

                // flower patch check
                if (hasPatch
                    && patchCenter.x - 7 <= targetFlower.x && targetFlower.x <= patchCenter.x + 7
                    && patchCenter.z - 7 <= targetFlower.z && targetFlower.z <= patchCenter.z + 7
                    )
                {
                    usedFlowers |= 1 << ix;
                }

            }
        }
    }

    const uint32_t fullMask = (1 << targetFlowerCount) - 1;
    if (worldseed == CORRECT_SEED)
    {
        printf("Total flowers = %d\n", targetFlowerCount);
        printf("Result mask = %x\n", usedFlowers);
		printf("Full mask = %x\n", fullMask);
    }

    if (usedFlowers == fullMask)
    {
        printSignedSeed(worldseed);
    }
}

// --------------------------------------------------------------------------------------------

constexpr uint64_t TEXT_SEEDS_TOTAL = 1ULL << 16; // limited for testing

__global__ void crackSeedTest()
{
    uint64_t tid = threadIdx.x + (uint64_t)blockDim.x * blockIdx.x;
    if (tid >= TEXT_SEEDS_TOTAL) return;
    secondaryFilter(tid);
}


int setupConstantMemory()
{
    /*
    data/flowersTest3_A.txt -> 1325
	data/flowersTest3_B.txt -> 11111
	data/flowersTest3_C.txt -> 6969
    */
    FILE* fptr = fopen("data/flowersTest3_C.txt", "r");
    if (fptr == NULL)
        HOST_ERROR("couldn't open input file");

    BlockPos flowers[MAX_FLOWERS];
    int flowerCount = 0;

    BlockPos2D posMin = { INT_MAX, INT_MAX };
    BlockPos2D posMax = { INT_MIN, INT_MIN };

    while (flowerCount < MAX_FLOWERS && fscanf(fptr, "%d%d%d", &(flowers[flowerCount].x), &(flowers[flowerCount].y), &(flowers[flowerCount].z)) == 3)
    {
        if (flowers[flowerCount].x < posMin.x) posMin.x = flowers[flowerCount].x;
        if (flowers[flowerCount].z < posMin.z) posMin.z = flowers[flowerCount].z;
        if (flowers[flowerCount].x > posMax.x) posMax.x = flowers[flowerCount].x;
        if (flowers[flowerCount].z > posMax.z) posMax.z = flowers[flowerCount].z;
        flowerCount++;
    }

    fclose(fptr);

    CHECKED_OPERATION(cudaMemcpyToSymbol(targetFlowers, flowers, sizeof(BlockPos) * flowerCount));
    CHECKED_OPERATION(cudaMemcpyToSymbol(targetFlowerCount, &flowerCount, sizeof(int)));

    // calculate the bounds for the region of relevant chunks
    ChunkPos regionMin_H = { (posMin.x - 7) >> 4, (posMin.z - 7) >> 4 };
    ChunkPos regionMax_H = { (posMax.x + 7) >> 4, (posMax.z + 7) >> 4 };

    CHECKED_OPERATION(cudaMemcpyToSymbol(regionMin, &regionMin_H, sizeof(ChunkPos)));
    CHECKED_OPERATION(cudaMemcpyToSymbol(regionMax, &regionMax_H, sizeof(ChunkPos)));

    return 0;
}

int main()
{
    CHECKED_OPERATION(cudaSetDevice(0));

    auto start = std::chrono::high_resolution_clock::now();

    if (setupConstantMemory() != 0)
        return 1;

    resultID2 = 0;

    const int THREADS_PER_BLOCK = 512;
    const int NUM_BLOCKS_2 = (TEXT_SEEDS_TOTAL + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    crackSeedTest <<< NUM_BLOCKS_2, THREADS_PER_BLOCK >>> ();
    CHECKED_OPERATION(cudaGetLastError());
    CHECKED_OPERATION(cudaDeviceSynchronize());

    auto end = std::chrono::high_resolution_clock::now();
    auto elapsed = end - start;
    double ms = (double)elapsed.count() / 1000000.0;
    printf("Kernel took %lf ms\n", ms);

    CHECKED_OPERATION(cudaDeviceReset());

    return 0;
}
